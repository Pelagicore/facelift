/**********************************************************************
**
** Copyright (C) Luxoft Sweden AB 2018
**
** This file is part of the documentation of the FaceLift project
**
** This work is licensed under the Creative Commons
** Attribution-ShareAlike 4.0 International License. To view a copy of
** this license, visit http://creativecommons.org/licenses/by-sa/4.0/
** or send a letter to Creative Commons, PO Box 1866, Mountain View,
** CA 94042, USA.
**
** SPDX-License-Identifier: CC-BY-SA-4.0
**
**********************************************************************/

/**

\page Reference

\section Generated C++ and QML Types

This section describes the types which are generated by the code generator for every interface
defined in a QFace file. We will take the example of an interface called "MyInterface", which could
look like the following:
\snippet mypackage.qface indoc

\subsection i Generated C++ Types

The following table describes the C++ classes which are generated from the QFace definition of
"MyInterface".

|C++ class name                      | Description | Required annotation |
|----------------------------------- |:-----------:|---------------------|
|MyInterface                         | This C++ abstract class (or interface) is the direct translation of the QFace interface definition into C++. Any concrete implementation of "MyInterface" should extend somehow this class (not necessarily directly) | none |
|MyInterfaceImplementationBase       | This C++ abstract class extends "MyInterface" and provides a more convenient base class to write an implementation of "MyInterface". | none |
|MyInterfaceQMLFrontend              | This class wraps an instance of "MyInterface" into an object which can be exposed directly to QML. Note that the "MyInterface" class is intentionally not QML-friendly. | none |
|MyInterfaceImplementationBaseQML    | This class is used to enable the implementation of "MyInterface" using the QML language. | none |
|MyInterfaceIPCAdapter               | This class is used to make an implementation of "MyInterface" accessible through an IPC. | \@ipc-sync: true or \@ipc-async: true |
|MyInterfaceIPCProxy                 | This class is an IPC proxy for the "MyInterface" type. A proxy object implements the same interface as the actual implementation object, which typically lives in another process. | \@ipc-sync: true |
|MyInterfaceAsyncIPCProxy            | This class is an asynchronous IPC proxy for the "MyInterface" type. Asynchronous proxies only contain asynchronous (non-blocking) methods. | \@ipc-async: true |
|MyInterfaceMonitor                  | This class provides a minimalistic Qt-Widget based GUI window which shows the state (property values) of an implementation of "MyInterface". It can also be used to invoke methods (TBD) and to log any signal triggered by the implementation. | none |
|MyInterfaceDummy                    | This type is an implementation of "MyInterface" which shows a control GUI where property values can be set manually, and signals can be triggered. It can be useful during development, in order to test the behavior of the UI code under specific conditions, or when an actual implement of the interface is not available yet. | none |


The following graph depicts the relationship among the types:

\startuml

abstract class MyInterface #88CCDD {
    C++ abstract class defining the interface
}


class MyInterfaceQMLFrontend #88CCDD {
    This class wraps an instance of "MyInterface" into an object which can be exposed directly to QML
}
MyInterfaceQMLFrontend --> "provider" MyInterface


class MyInterfaceImplementationBase {
}
MyInterfaceImplementationBase --|> MyInterface : extends


class MyInterfaceIPCProxy {
    This class is an IPC proxy for the "MyInterface" type
}
MyInterfaceIPCProxy --|> MyInterfaceImplementationBase : extends


class MyInterfaceDummy {

}
MyInterfaceDummy --|> MyInterfaceImplementationBase : extends


class MyInterfaceImplementationBaseQML {
    Used as base component when implementing "Interface" using QML code
}
MyInterfaceImplementationBaseQML --> "provider" MyInterfaceImplementationBase

\enduml


\subsection ii Generated QML Types

The following table describes the QML types:

QML component name               | Corresponding C++ class           | Description
-------------------------------- | --------------------------------- | -----------------------
MyInterfaceImplementationBase    | MyInterfaceImplementationBaseQML  | This type is used to enable the implementation (backend) of "MyInterface" using the QML language.
MyInterface <i>(you name it)</i> | MyInterfaceQMLFrontend            | This class exposes the interface defined in the IDL to QML (frontend UI)
MyInterfaceIPCProxy              | MyInterfaceIPCQMLFrontendType     | This type is an IPC proxy for the "MyInterface" type. A proxy object implements the same interface as the actual implementation object, which typically lives in another process.

\subsection reference-registration QML Type Registration

In your QML plugin implementation the auto-generated \c Module::registerQmlTypes method should be
called (defined in the generated Module.h file):
\code
Module:registerQmlTypes(uri)
\endcode
In our example it will register the C++ classes \c MyInterfaceImplementationBaseQML as QML type \c
MyInterfaceImplementationBase (for backend usage) and \c MyInterfaceIPCProxy with identical name to
QML (for UI usage). The \c MyInterfaceIPCProxy type will only be registered, if IPC is enabled. In
addition this method registers structures (with annotation <tt>\@qml-component: true</tt>) and
enums as QML types with the same name as given in the QFace document. For usage in JavaScript there
is also a QML singleton type registered with the postfix "Factory" for each structure. This type
exports a \c create() method, that instantiates and returns a structure of this type. Suppose there
would be a
\code
struct MyStruct {
    int i
}
\endcode
definition in the QFace document, then a \c MyStructFactory QML singleton type would be available
that could be used as follows form the QML backend or UI code:
\code
var ms = MyStructFactory.create();
ms.i = 1;
\endcode

There is another type registration method that can be called from the QML plugin:
\code
Module::registerUncreatableQmlTypes(uri);
\endcode
This will register all interfaces defined in the QFace document as uncreatable types to the QML
engine. In our example it will register the \c MyInterfaceQMLFrontend type as an uncreatable type
to the QML engine. The QML name will simply be the interface name, in our case: \c MyInterface.

\subsubsection reference-registration-ui UI (Frontend) Type Registration

The \c MyInterfaceQMLFrontend has to be registered manually since we need to define whether the C++
or QML backend implementation should be used. Hence, this class can be exposed to QML with an
arbitrary name. The name defaults to the interface name ("MyInterface" here). The following
registration function should be used when providing a C++ implementation (defined in
QMLFrontend.h):
\code
template<typename ProviderType>
int facelift::registerQmlComponent(const char *uri,
                                   const char *name = ProviderType::INTERFACE_NAME,
                                   int majorVersion = ProviderType::VERSION_MAJOR,
                                   int minorVersion = ProviderType::VERSION_MINOR);
\endcode
This registration function should be used when providing a QML implementation (defined in
QMLModel.h):
\code
template<typename ImplementationBaseQMLType>
int facelift::registerQmlComponent(const char *uri,
                                   const char *qmlFilePath,
                                   const char *componentName = ImplementationBaseQMLType::Provider::QMLFrontendType::INTERFACE_NAME,
                                   int majorVersion = ImplementationBaseQMLType::Provider::VERSION_MAJOR,
                                   int minorVersion = ImplementationBaseQMLType::Provider::VERSION_MINOR);
\endcode
Both return the QML type id. The registered types are instantiatable from QML.

This is how the C++ implementation can be registered (explicitly as "MyInterface"), assuming that
you provide an implementation class called \c MyInterfaceImplementation:
\code
facelift::registerQmlComponent<MyInterfaceImplementation>(uri, "MyInterface");
\endcode

And here is how the QML implementation can be registered (explicitly as "MyInterface"), assuming
that you provide a QML implementation component called \c MyInterfaceImplementation (derived from
the QML type \c MyInterfaceImplementationBase):
\code
facelift::registerQmlComponent<MyInterfaceImplementationBaseQML>(uri, "path/to/MyInterfaceImplementation.qml", "MyInterface");
\endcode

If only the type itself is needed for instance to define a typed property or only enum values from
the type are needed, the type can be registered as "uncreatable":
\code
facelift::registerUncreatableQmlComponent<MyInterface>(uri, "MyInterfaceType");
\endcode

Note again that all the above registration functions actually register a \c MyInterfaceQMLFrontend
(derived) type to the QML engine internally. This type exactly reflects all the properties, methods
and signals defined in the .qface file.

There are equivalent functions to register a singleton type (in contrast to an instantiatable type
above). The QML name also defaults to the interface name ("MyInterface" here). The following calls
will register a singleton with the explicit name \c MyInterfaceSingleton. C++ backend
implementation:
\code
facelift::registerSingletonQmlComponent<MyInterfaceImplementation>(uri, "MyInterfaceSingleton");
\endcode
or with a QML backend implementation:
\code
facelift::registerSingletonQmlComponent<MyInterfaceImplementationBaseQML>(uri, "/path/to/MyInterfaceImplementation.qml", "MyInterfaceSingleton");
\endcode


\section reference-usage Usage of Types

It is important to understand what types are meant to be used to implement the interface (backend)
and what types are supposed to be used from the frontend (UI) QML code.

\subsection reference-backend Backend Implementation

The backend service implementation can be done either in C++ or QML:

C++/QML type                     | Lang. | Usage
-------------------------------- | ----- | ----------------------------
\b MyInterfaceImplementationBase | C++   | Use this class as the base class for your C++ implementation
\b MyInterfaceImplementationBase | QML   | Use this QML type as the base for your QML implementation

\subsection reference-frontend Frontend UI

In the QML UI code the following types can be used:

QML type                            | Corresponding C++ type        | Usage
----------------------------------- | ----------------------------- | ----------------------------
\b MyInterface <i>(you name it)</i> | MyInterfaceQMLFrontend        | Exposed interface defined in the IDL, derived from \c MyInterfaceQMLFrontend (see above for how it is registered)
\b MyInterfaceIPCProxy              | MyInterfaceIPCQMLFrontendType | This type is exposed to clients, it provides the same API as MyInterface above
\b IPC                              | IPCServiceAdapterBase         | This attached property can be used on the server side to enable IPC

\subsection reference-difference Differences between QML Types

Note how \c MyInterface (derived from \c MyInterfaceQMLFrontend) and
\c MyInterfaceImplementationBaseQML differ: the latter is used when writing an implementation of an
interface using the QML language, which means all the properties defined in the IDL are writable,
and the signals can be triggered, whereas the properties exposed by \c MyInterface are read-only,
if they are defined readonly in the IDL definition.

*/
