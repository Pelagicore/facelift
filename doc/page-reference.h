/**********************************************************************
**
** Copyright (C) Luxoft Sweden AB 2018
**
** This file is part of the documentation of the FaceLift project
**
** This work is licensed under the Creative Commons
** Attribution-ShareAlike 4.0 International License. To view a copy of
** this license, visit http://creativecommons.org/licenses/by-sa/4.0/
** or send a letter to Creative Commons, PO Box 1866, Mountain View,
** CA 94042, USA.
**
** SPDX-License-Identifier: CC-BY-SA-4.0
**
**********************************************************************/

/**

\page Reference

\section Generated C++ and QML Types

This section describes the types which are generated by the code generator for every interface
defined in a QFace file. We will take the example of an interface called "MyInterface", which could
look like the following:
\snippet mypackage.qface indoc

\subsection i Generated C++ Types

The following table describes the C++ classes which are generated from the QFace definition of
"MyInterface".

C++ class name                      | Description
----------------------------------- | -------------
MyInterface                         | This C++ abstract class (or interface) is the direct translation of the QFace interface definition into C++. Any concrete implementation of "MyInterface" should extend somehow this class (not necessarily directly)
MyInterfacePropertyAdapter          | This C++ abstract class extends "MyInterface" and provides a more convenient base class to write an implementation of "MyInterface".
MyInterfaceQMLFrontend              | This class wraps an instance of "MyInterface" into an object which can be exposed directly to QML. Note that the "MyInterface" class is intentionally not QML-friendly.
MyInterfaceQMLImplementation        | This class is used to enable the implementation of "MyInterface" using the QML language.
MyInterfaceIPCAdapter               | This class is used to make an implementation of "MyInterface" accessible through an IPC.
MyInterfaceIPCProxy                 | This class is an IPC proxy for the "MyInterface" type. A proxy object implements the same interface as the actual implementation object, which typically lives in another process.
MyInterfaceMonitor                  | This class provides a minimalistic Qt-Widget based GUI window which shows the state (property values) of an implementation of "MyInterface". It can also be used to invoke methods (TBD) and to log any signal triggered by the implementation.
MyInterfaceDummy                    | This type is an implementation of "MyInterface" which shows a control GUI where property values can be set manually, and signals can be triggered. It can be useful during development, in order to test the behavior of the UI code under specific conditions, or when an actual implement of the interface is not available yet.


The following graph depicts the relationship among the types:

\startuml

abstract class MyInterface #88CCDD {
    C++ abstract class defining the interface
}


class MyInterfaceQMLFrontend #88CCDD {
    This class wraps an instance of "MyInterface" into an object which can be exposed directly to QML
}
MyInterfaceQMLFrontend --> "provider" MyInterface


class MyInterfacePropertyAdapter {
}
MyInterfacePropertyAdapter --|> MyInterface : extends


class MyInterfaceIPCProxy {
    This class is an IPC proxy for the "MyInterface" type
}
MyInterfaceIPCProxy --|> MyInterfacePropertyAdapter : extends


class MyInterfaceDummy {

}
MyInterfaceDummy --|> MyInterfacePropertyAdapter : extends


class MyInterfaceQMLImplementation {
    Used as base component when implementing "Interface" using QML code
}
MyInterfaceQMLImplementation --> "provider" MyInterfacePropertyAdapter

\enduml


\subsection ii Generated QML Types

The following table describes the QML types:

QML component name               | Corresponding C++ class       | Description
-------------------------------- | ----------------------------- | -----------------------
MyInterfaceQMLImplementation     | MyInterfaceQMLImplementation  | This type is used to enable the implementation of "MyInterface" using the QML language.
MyInterface <i>(you name it)</i> | MyInterfaceQMLFrontend        | This class exposes the interface defined in the IDL to QML
MyInterfaceIPCProxy              | MyInterfaceIPCQMLFrontendType | This type is an IPC proxy for the "MyInterface" type. A proxy object implements the same interface as the actual implementation object, which typically lives in another process.

\subsubsection reference-registration QML Type Registration

In your QML plugin implementation you should call the auto-generated \c Module::registerQmlTypes
method. This will register the C++ classes \c MyInterfaceQMLImplementation and
\c MyInterfaceIPCProxy with identical name to QML. The \c MyInterfaceQMLFrontend has to be
registered separately since we need to define whether the C++ or QML backend implementation should
be used. Hence, this class can be exposed to QML with an arbitrary name. The name defaults to the
interface name ("MyInterface" here).

This is how the C++ implementation can be registered (explicitely as "MyInterface"), assuming that
you provide an implementation called \c MyInterfaceCppImplementation:
\code
facelift::registerQmlComponent<MyInterfaceCppImplementation>(uri, "MyInterface");
\endcode

And here is how the QML implementation can be registered (explicitely as "MyInterface"), assuming
that you provide a QML implementation called \c MyInterfaceImplementation (derived from
\c MyInterfaceQMLImplementation):
\code
facelift::registerQmlComponent<MyInterfaceQMLImplementation>(uri, STRINGIFY(QML_MODEL_LOCATION)
                                     "/models/qml/MyInterfaceImplementation.qml", "MyInterface");
\endcode
Note again that both calls actually register a \c MyInterfaceQMLFrontend derived type to the QML
engine. This is done implicitely without mentioning this type.


\section reference-usage Usage of Types

It is important to understand what types are meant to be used to implement the interface (backend)
and what types are supposed to be used from the frontend (UI) QML code.

\subsection reference-backend Backend Implementation

The backend service implementation can be done either in C++ or QML:

C++/QML type                    | Lang. | Usage
------------------------------- | ----- | ----------------------------
\b MyInterfacePropertyAdapter   | C++   | Use this class as the base class for your C++ implementation
\b MyInterfaceQMLImplementation | QML   | Use this QML type as the base for your QML implementation

\subsection reference-frontend Frontend UI

In the QML UI code the following types can be used:

QML type                            | Corresponding C++ type        | Usage
----------------------------------- | ----------------------------- | ----------------------------
\b MyInterface <i>(you name it)</i> | MyInterfaceQMLFrontend        | Exposed interface defined in the IDL, derived from \c MyInterfaceQMLFrontend (see above for how it is registered)
\b MyInterfaceIPCProxy              | MyInterfaceIPCQMLFrontendType | This type is exposed to clients, it provides the same API as MyInterface above
\b IPC                              | IPCServiceAdapterBase         | This attached property can be used on the server side to enable IPC

\subsection reference-difference Differences between QML Types

Note how \c MyInterface (derived from \c MyInterfaceQMLFrontend) and
\c MyInterfaceQMLImplementation differ: the latter is used when writing an implementation of an
interface using the QML language, which means all the properties defined in the IDL are writable,
and the signals can be triggered, whereas the properties exposed by \c MyInterface are read-only,
if they are defined readonly in the IDL definition.

*/
